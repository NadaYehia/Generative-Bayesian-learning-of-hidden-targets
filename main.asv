
clear all
clc
% setup the environment: the arena size, number of target, special objects
% (e.g. obstacles) *to be added*
close all
targets_xy=[10 250; 200 250]; % 2Dcenters per target: nx2
targets_sizes=[60 60; 60 60];  % target sizes in x&y: nx2
arena_size=[-400 400 0 600];
arena.x=[arena_size(1) arena_size(2) arena_size(2) arena_size(1)];
arena.y=[arena_size(3) arena_size(3) arena_size(4) arena_size(4)];
env=environment;
env.intercept="anypt";
env.blocks=[60 150]; % number of trials per target: 1xn
env.targets_centers=targets_xy; 
env.targets_dimensions= targets_sizes; 
env.arena_dimensions= arena_size;  % arena size 1x4
targets=env.setup_targets_coord; % outputs nx2 struct: each row is a target
                                 % col1 are the x coords and col2 are the 
                                 % ycoords of the target corners


sigma_ridge=20; %uncertainity in the value of the action parameters executed.
ags=50;   %number of agents to run
n=500;    %number of samples in speed space and angle space.
max_speed=1000;  %maximum speed value in the action space.
min_speed=1;     % minimum speed value in the action space
max_angle=pi/2;  %maximum angle in the action space (relative to the vertical axis) 
min_angle=-pi/2;   %minimum angle in the action space (relative to the vertical axis)
speed_step=round((max_speed-min_speed)/n);
As=linspace(min_speed,max_speed,n);
Os=linspace(min_angle,max_angle,n);
clearnce=1.57; %loop width in radians
sampler='proportional';
% sampler='peak_sampler';
c_drift=0.25; %1.6
draw_flg=0;
target_num=2;
kmerge=1;
merging_criterion= (kmerge*sigma_ridge)/n; % converting sigma ridge from pixels distance to normalized dist.
win=1;
tic

% start agents trials
parfor agent=1:ags

initial_ancs=10;
dd=sum(env.blocks(target_num));
mu_spd=zeros(1, dd );
om_main=zeros(1, dd );      
target_hit=zeros(1, dd ); 
hit_time = ones(1, dd  ); 
anchors_no= zeros(1,dd);
[prior,r_bounds,c_bounds]= set_control_actions_space(As,Os,env.arena_dimensions,clearnce);

mu_anchors_variance={};
omega_anchors_variance={};
anchors_no_variance={};
posterior_support_mu_var=zeros(1,dd);
posterior_support_omega_var=zeros(1,dd); 
posterior_support_mu_entropy=zeros(1,dd);
posterior_support_omega_entropy=zeros(1,dd);

%% starting the simulation for a model agent
for k=1:dd
             
     % for first run, pick n action anchors randomly from the prior, connect
     % them smoothly in xy space and find all the actions along this smooth
     % trajectory

     if(k==1) 

       % Excludes boundary actions from the initial samples to prevent
       % choosing a false peak at the boundary pixels where the matrix
       % is circular  
       
       lin_idx_bounds=sub2ind(size(prior),r_bounds,c_bounds);
       lrw=size(prior,1);
       % add the indices for the first row, last row, and first column
       ind_first_row= sub2ind(size(prior),repmat(1,size(prior,2),1), (1:size(prior,2))');
       ind_last_row= sub2ind(size(prior),repmat(lrw,size(prior,2),1),(1:size(prior,2))');
       lin_idx_bounds=[lin_idx_bounds, [1:size(prior,1)], ind_first_row', ind_last_row'];
       
       l_ind=[];
       ancs=initial_ancs;
    
       % sample till all the first n anchors are non-boundary
       % actions
       while(numel(l_ind)~=initial_ancs)
        
        action_array=[1:size(prior,1)*size(prior,2)];
        [temp]=datasample(action_array,ancs,'Replace',false,'Weights',(prior(:)));
    
        not_peaks=find(ismember(temp,lin_idx_bounds));
        temp(not_peaks)=[];
        l_ind=[l_ind,temp];
        ancs=initial_ancs-numel(l_ind);
    
       end
    
       [omega_temp_ind,mu_temp_ind]=ind2sub(size(prior),l_ind);
    
       mu_anchors=As(mu_temp_ind);
       omega_anchors=Os(omega_temp_ind);
                                         
       [~,min_speed_anchor]=min(mu_anchors);
       initial_hd=omega_anchors(min_speed_anchor);
    
      %% the generative model connecting anchors with a smooth trajectory 
       Gsol=connect_anchors_tsp([0 mu_anchors]',[ initial_hd omega_anchors]',initial_ancs+1,As,Os);
       [mu_anchors,omega_anchors]=reorder_actions_anchors([0 mu_anchors],[ initial_hd omega_anchors],Gsol);
       [mus_,omegas_,pos_x,pos_y]= connect_actions_with_smooth_trajectory(mu_anchors,omega_anchors,sigma_ridge,speed_step,env,clearnce,c_drift);
    
       % keep track of mean heading and speeds
       om_main(k)=mean(omegas_);
       mu_spd(k)=mean(mus_);      

     else
        % keep track of mean heading and speeds
        om_main(k)=mean(omegas_);
        mu_spd(k)=mean(mus_);   
       
     end

   [target_hit(k),hit_time(k)]=simulate_a_run(pos_x,pos_y,target_num,env,target_hit(k),hit_time(k));
%% Baye's update of the control actions space given the outcome of a trajectory: reward=0/1
   [posterior]=Bayes_update_for_actions_params(target_hit(k),mus_,omegas_,sigma_ridge,As,Os,prior);
%% sampler function for the next actions calling either: proportional or peak sampler
   [mu_anchors,omega_anchors,anchors_no(k)]= Sampling_next_actions(posterior,sampler,initial_ancs,As,Os,merging_criterion,r_bounds,c_bounds);
   
   
   [~,min_speed_anchor]=min(mu_anchors);
   initial_hd=omega_anchors(min_speed_anchor);
 
     if(anchors_no(k)>1)
    
         %% the generative model connecting anchors with a smooth trajectory 
         Gsol=connect_anchors_tsp([0 mu_anchors]',[ initial_hd omega_anchors]',anchors_no(k)+1,As,Os);       
         [mu_anchors,omega_anchors]=reorder_actions_anchors([0 mu_anchors],[ initial_hd omega_anchors],Gsol);
         [mus_new,omegas_new,pos_xnew,pos_ynew]= connect_actions_with_smooth_trajectory(mu_anchors,omega_anchors,sigma_ridge,speed_step,env,clearnce);
     else
         mu_anchors=[0 mu_anchors 0];
         omega_anchors=[omega_anchors, omega_anchors, omega_anchors];
         %% the generative model connecting anchors with a smooth trajectory 
         [mus_new,omegas_new,pos_xnew,pos_ynew]= connect_actions_with_smooth_trajectory(mu_anchors,omega_anchors,sigma_ridge,speed_step,env,clearnce);
         
      end
    
   prior=posterior;
   
   %% compute variability of posterior Vs variability in anchors

     [lind]= datasample(action_array,100,'Replace',false,'Weights',(posterior(:)));
     [omega_ind,mu_ind]=ind2sub(size(posterior),lind);
    
     posterior_support_mu_var(k)= var(As(mu_ind));
     posterior_support_omega_var(k)=var(Os(omega_ind));
    
     posterior_support_omega_entropy(k)=my_entropy(posterior);
     posterior_support_mu_entropy(k)=my_entropy(posterior);


     mu_anchors_variance{k}=(mu_anchors);
     omega_anchors_variance{k}=(omega_anchors);
     anchors_no_variance{k}=anchors_no(k);

   %% draw the arena, current trajectory, next sampled actions
   if(draw_flg==1)
       figure(2);
       imagesc(As,Os,prior);
      
       hold on, scatter(mu_anchors,omega_anchors,30,'r','filled');
       hold off;
       figure(1);       
       hold on, plot(pos_x,pos_y,'LineWidth',0.5,'Color',[1 0.1 0.8 0.5]);
       hold on,scatter(pos_x,pos_y,10,[1:numel(pos_y)],'filled');
      
       clf;
       patch(arena.x,arena.y,[0.95 0.9 0.95]); hold on;
       patch(targets(target_num).x,targets(target_num).y,[0.85 0.9 0.9]);
   end
 

  % empty the current trajectory posx and posy variables
   pos_x=[]; pos_y=[];
  % replace the new vectors with the next trajectory xy points
  pos_x=pos_xnew;
  pos_y=pos_ynew;

 % set current actions to the new ones
  mus_=mus_new;
  omegas_=omegas_new;

end

%% 
mu_pop_avg(agent,:) = mu_spd;
hd_pop_avg(agent,:)=om_main;
corr_pop_avg(agent,:) = target_hit;
anchors_no_pop(agent,:)=anchors_no;

% compute posterior support (as variance in its samples or entropy) to
% compare it with variance in executed anchors
dd= size(posterior_support_omega_entropy,2);
l=1;
var_x_mu_temp1=zeros(1,(dd-(2*win)));
var_x_mu_temp2=zeros(1,(dd-(2*win)));
var_y_mu_temp=zeros(1,(dd-(2*win)));
var_x_om_temp1=zeros(1,(dd-(2*win)));
var_x_om_temp2=zeros(1,(dd-(2*win)));
var_y_om_temp=zeros(1,(dd-(2*win)));


   for sc=win+1:dd-win
       var_x_mu_temp1(l)=(posterior_support_mu_var(sc));
       var_x_mu_temp2(l)=(posterior_support_mu_entropy(sc));
       
       var_y_mu_temp(l)= var( cell2mat(mu_anchors_variance(sc-win:sc+win)) );
       
       var_x_om_temp1(l)=(posterior_support_omega_var(sc));
       var_x_om_temp2(l)=(posterior_support_omega_entropy(sc));

       var_y_om_temp(l)= var( cell2mat(omega_anchors_variance(sc-win:sc+win)) );

       l=l+1;
   end

   var_x_mu(agent,:)=var_x_mu_temp1;
   entropy_x_mu(agent,:)=var_x_mu_temp2;
   var_y_mu(agent,:)=var_y_mu_temp;

   var_x_om(agent,:)=var_x_om_temp1;
   entropy_x_om(agent,:)=var_x_om_temp2;
   var_y_om(agent,:)=var_y_om_temp;



end

toc
